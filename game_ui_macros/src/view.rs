use proc_macro::TokenStream;
use proc_macro2::{Ident, Span, TokenStream as TokenStream2};
use quote::{quote, ToTokens};
use syn::parse::{Parse, ParseStream};
use syn::{parse_macro_input, ExprBlock, Result, Token};

pub fn view(input: TokenStream) -> TokenStream {
    let node = parse_macro_input!(input as ViewInput);
    node.into_token_stream().into()
}

struct ViewInput {
    cx: Ident,
    nodes: Vec<Node>,
}

impl Parse for ViewInput {
    fn parse(input: ParseStream) -> Result<Self> {
        let cx = input.parse()?;
        input.parse::<Token![,]>()?;

        let mut nodes = Vec::new();
        while !input.is_empty() {
            let node = input.parse()?;
            nodes.push(node);
        }

        Ok(Self { cx, nodes })
    }
}

impl ToTokens for ViewInput {
    fn to_tokens(&self, tokens: &mut TokenStream2) {
        let cx = &self.cx;
        let nodes: TokenStream2 = self.nodes.iter().map(|n| quote! { #n }).collect();

        tokens.extend(quote! {
            {
                let cx = &#cx;
                #nodes
            }
        });
    }
}

#[derive(Clone, Debug)]
struct Node {
    name: Ident,
    children: Vec<Node>,
    attrs: Vec<(Ident, ExprBlock)>,
}

impl Parse for Node {
    fn parse(input: ParseStream) -> Result<Self> {
        // Head
        input.parse::<Token![<]>()?;
        let name = input.parse()?;

        // Attributes
        let mut attrs = Vec::new();
        while !input.peek(Token![>]) {
            let ident = input.parse()?;
            input.parse::<Token![=]>()?;
            let expr = input.parse()?;

            attrs.push((ident, expr));
        }

        input.parse::<Token![>]>()?;

        // Children
        let mut children = Vec::new();
        if input.peek(Token![<]) && !input.peek2(Token![/]) {
            let node = input.parse()?;
            children.push(node);
        }

        // Tail
        input.parse::<Token![<]>()?;
        input.parse::<Token![/]>()?;

        let name2 = input.parse::<Ident>()?;
        assert_eq!(name, name2);

        input.parse::<Token![>]>()?;

        Ok(Self {
            name,
            children,
            attrs,
        })
    }
}

impl ToTokens for Node {
    fn to_tokens(&self, tokens: &mut TokenStream2) {
        let name = self.name.clone();

        let attrs: TokenStream2 = self
            .attrs
            .iter()
            .map(|(id, expr)| {
                quote! {
                    #id: #expr,
                }
            })
            .collect();

        let children: TokenStream2 = self
            .children
            .iter()
            .map(|child| {
                quote! {
                    #child
                }
            })
            .collect();

        // FIXME: This is currently suboptimal for two reasons:
        // 1. This requires the properties struct to have the name in the exact same
        // form as generated by the `component` macro.
        // 2. This requires that the properties struct is in scope. Since we have no
        // idea of the origin we cannot manually import it.
        //
        // Both issues are resolved by https://github.com/rust-lang/rust/issues/86935
        // once stable.
        let props_ident = Ident::new(&format!("{}Props", name), Span::call_site());

        tokens.extend(quote! {
            {
                let mut props = #props_ident {
                    #attrs
                };

                let cx = <#name as ::game_ui::widgets::Component>::render(&cx, props);
                #children;

                cx
            }
        });
    }
}
